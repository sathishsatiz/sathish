#!/usr/bin/env python3
"""
graph_project.py

Complete implementation for:
 - Graph (adjacency list, directed, weighted)
 - Dijkstra's shortest path (min-heap)
 - A* search with Euclidean / zero heuristic
 - Graph generators:
     * geometric_graph(n, k_neighbors) -> weights = Euclidean distances (admissible heuristic)
     * random_weight_graph(n, m) -> abstract weights (heuristic may be inadmissible)
 - Experiment harness: runs multiple source-target pairs, times, counts nodes expanded, writes CSV, prints summary.

Usage:
    python graph_project.py           # runs default experiment (100 nodes, ~500 edges)
    python graph_project.py --help    # prints options

This is designed for clarity and reproducibility, not micro-optimized speed.
"""

import heapq
import math
import random
import time
import csv
import argparse
from collections import defaultdict, deque

# ---------------------------
# Graph data structure
# ---------------------------

class Graph:
    def __init__(self, directed=True):
        # adjacency: node -> list of (neighbor, weight)
        self.adj = defaultdict(list)
        self.directed = directed

    def add_edge(self, u, v, w):
        """Add directed edge u -> v with weight w."""
        self.adj[u].append((v, w))
        if not self.directed:
            self.adj[v].append((u, w))

    def neighbors(self, u):
        return self.adj.get(u, [])

    def nodes(self):
        # return all nodes seen in adjacency keys and neighbor destinations
        s = set(self.adj.keys())
        for u, neighbors in self.adj.items():
            for v, _ in neighbors:
                s.add(v)
        return sorted(s)

    def __len__(self):
        return len(self.nodes())

# ---------------------------
# Path reconstruction helper
# ---------------------------

def reconstruct_path(came_from, start, goal):
    if goal not in came_from and start != goal:
        return []
    path = [goal]
    cur = goal
    while cur != start:
        cur = came_from.get(cur)
        if cur is None:
            return []  # no path
        path.append(cur)
    path.reverse()
    return path

# ---------------------------
# Dijkstra's algorithm
# ---------------------------

def dijkstra(graph, start, goal):
    """
    Returns: (distance, path, nodes_expanded)
    nodes_expanded = number of times a node was popped from the priority queue.
    """
    pq = [(0.0, start)]
    dist = {start: 0.0}
    came_from = {}
    visited_set = set()
    nodes_expanded = 0

    while pq:
        cost, node = heapq.heappop(pq)
        # Skip stale entry
        if cost > dist.get(node, float('inf')):
            continue
        nodes_expanded += 1
        if node == goal:
            path = reconstruct_path(came_from, start, goal)
            return dist[goal], path, nodes_expanded

        for nei, w in graph.neighbors(node):
            new_cost = cost + w
            if new_cost < dist.get(nei, float('inf')):
                dist[nei] = new_cost
                came_from[nei] = node
                heapq.heappush(pq, (new_cost, nei))

    # unreachable
    return float('inf'), [], nodes_expanded

# ---------------------------
# A* algorithm
# ---------------------------

def euclidean_heuristic(a, b, coords):
    (ax, ay) = coords[a]
    (bx, by) = coords[b]
    return math.hypot(ax - bx, ay - by)

def zero_heuristic(a, b, coords):
    return 0.0

def astar(graph, start, goal, coords, heuristic_fn):
    """
    Returns: (distance, path, nodes_expanded)
    g-score = best-known cost from start to node
    f = g + h
    """
    pq = [(heuristic_fn(start, goal, coords), start)]
    gscore = {start: 0.0}
    came_from = {}
    nodes_expanded = 0

    while pq:
        f, node = heapq.heappop(pq)
        # If this f is stale (no direct mapping), skip
        g = gscore.get(node, float('inf'))
        if f - heuristic_fn(node, goal, coords) > g + 1e-12:
            # stale
            continue
        nodes_expanded += 1

        if node == goal:
            path = reconstruct_path(came_from, start, goal)
            return gscore[goal], path, nodes_expanded

        for nei, w in graph.neighbors(node):
            tentative_g = g + w
            if tentative_g < gscore.get(nei, float('inf')):
                gscore[nei] = tentative_g
                came_from[nei] = node
                fval = tentative_g + heuristic_fn(nei, goal, coords)
                heapq.heappush(pq, (fval, nei))

    return float('inf'), [], nodes_expanded

# ---------------------------
# Graph generators
# ---------------------------

def geometric_graph(n=100, k_neighbors=6, radius=None, seed=None):
    """
    Create a directed geometric graph:
      - nodes have (x,y) coordinates in [0,1)^2 scaled later if desired
      - Add edges from each node to its k nearest neighbors (directed)
      - weight = Euclidean distance (so euclidean heuristic is admissible)
    Returns: (graph, coords)
    """
    if seed is not None:
        random.seed(seed)

    coords = {i: (random.random(), random.random()) for i in range(n)}
    g = Graph(directed=True)

    # For each node, find k nearest neighbors by Euclidean distance and add edge
    for i in range(n):
        dists = []
        xi, yi = coords[i]
        for j in range(n):
            if i == j:
                continue
            xj, yj = coords[j]
            dist = math.hypot(xi - xj, yi - yj)
            dists.append((dist, j))
        dists.sort()
        for d, j in dists[:k_neighbors]:
            g.add_edge(i, j, d)

    return g, coords

def random_weight_graph(n=100, m=500, min_w=1, max_w=20, seed=None, ensure_connected=True):
    """
    Create a directed graph with abstract random weights.
    If ensure_connected true, first make a simple spanning chain linking nodes, then add random edges.
    Returns: (graph, coords_placeholder)
    coords_placeholder is None because weights do not reflect geometry.
    """
    if seed is not None:
        random.seed(seed)

    g = Graph(directed=True)
    # optional placeholder coords (all zeros) so A* can still be called, but euclidean heuristic would be meaningless.
    coords = {i: (0.0, 0.0) for i in range(n)}

    if ensure_connected:
        # chain 0 -> 1 -> 2 -> ... -> n-1
        for i in range(n-1):
            w = random.uniform(min_w, max_w)
            g.add_edge(i, i+1, w)

    # add m edges at random
    added = 0
    trials = 0
    while added < m and trials < m*10:
        u = random.randint(0, n-1)
        v = random.randint(0, n-1)
        if u == v:
            trials += 1
            continue
        w = random.uniform(min_w, max_w)
        g.add_edge(u, v, w)
        added += 1

    return g, coords

# ---------------------------
# Experiments harness
# ---------------------------

def run_experiment(graph, coords, pairs, runs=1, heuristic='euclidean'):
    """
    Run both Dijkstra and A* on each (start,goal) pair.
    Returns a list of results dicts for each run and each pair.
    Each result dict contains:
        method, start, goal, distance, path_len, nodes_expanded, time_seconds
    heuristics:
      - 'euclidean' uses euclidean_heuristic (requires coords meaningful)
      - 'zero' uses zero_heuristic (A* reduces to Dijkstra)
    """
    results = []
    if heuristic == 'euclidean':
        heuristic_fn = euclidean_heuristic
    else:
        heuristic_fn = zero_heuristic

    for start, goal in pairs:
        # Run Dijkstra
        t0 = time.perf_counter()
        d_dist, d_path, d_nodes = dijkstra(graph, start, goal)
        t1 = time.perf_counter()
        results.append({
            'method': 'dijkstra',
            'start': start,
            'goal': goal,
            'distance': d_dist,
            'path_len': len(d_path),
            'nodes_expanded': d_nodes,
            'time_s': t1 - t0
        })

        # Run A*
        t0 = time.perf_counter()
        a_dist, a_path, a_nodes = astar(graph, start, goal, coords, heuristic_fn)
        t1 = time.perf_counter()
        results.append({
            'method': 'astar',
            'start': start,
            'goal': goal,
            'distance': a_dist,
            'path_len': len(a_path),
            'nodes_expanded': a_nodes,
            'time_s': t1 - t0
        })

    return results

# ---------------------------
# Utilities: CSV output + summary
# ---------------------------

def write_csv(filename, rows, fieldnames=None):
    if not fieldnames:
        fieldnames = ['method','start','goal','distance','path_len','nodes_expanded','time_s']
    with open(filename, 'w', newline='') as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for r in rows:
            w.writerow(r)

def summarize_results(rows):
    # rows is list of dicts produced by run_experiment
    # produce a simple grouped summary comparing Dijkstra vs A*
    from statistics import mean, median
    grouped = defaultdict(list)
    for r in rows:
        grouped[r['method']].append(r)

    lines = []
    for method, recs in grouped.items():
        times = [r['time_s'] for r in recs]
        nodes = [r['nodes_expanded'] for r in recs]
        dists = [r['distance'] for r in recs if math.isfinite(r['distance'])]
        lines.append(f"Method: {method}")
        if times:
            lines.append(f"  runs: {len(times)}, avg time: {mean(times):.6f}s, median time: {median(times):.6f}s")
        if nodes:
            lines.append(f"  avg nodes expanded: {mean(nodes):.2f}, median: {median(nodes):.2f}")
        if dists:
            lines.append(f"  avg found distance: {mean(dists):.4f}")
        lines.append("")
    return "\n".join(lines)

def pretty_table(rows):
    # print a comparison table per pair
    pairs = sorted(set((r['start'], r['goal']) for r in rows))
    header = f"{'start->goal':>10} | {'method':>8} | {'time_s':>9} | {'nodes':>7} | {'dist':>10} | {'path_len':>9}"
    sep = "-"*len(header)
    out = [header, sep]
    for (s,g) in pairs:
        for method in ('dijkstra','astar'):
            rec = next((r for r in rows if r['start']==s and r['goal']==g and r['method']==method), None)
            if rec:
                out.append(f"{s:2d}->{g:2d}     | {method:8s} | {rec['time_s']:9.6f} | {rec['nodes_expanded']:7d} | {rec['distance']:10.4f} | {rec['path_len']:9d}")
    return "\n".join(out)

# ---------------------------
# Command-line runner
# ---------------------------

def pick_random_pairs(n_nodes, num_pairs, seed=None, allow_same=False):
    if seed is not None:
        random.seed(seed)
    pairs = set()
    attempts = 0
    while len(pairs) < num_pairs and attempts < num_pairs*20:
        s = random.randint(0, n_nodes-1)
        t = random.randint(0, n_nodes-1)
        if not allow_same and s == t:
            attempts += 1
            continue
        pairs.add((s, t))
    return list(pairs)

def main():
    parser = argparse.ArgumentParser(description="Run Dijkstra vs A* experiments")
    parser.add_argument("--nodes", type=int, default=100, help="number of nodes")
    parser.add_argument("--edges", type=int, default=500, help="number of edges (for random graph)")
    parser.add_argument("--k", type=int, default=6, help="k nearest neighbors (geometric graph)")
    parser.add_argument("--graph-type", choices=['geometric','random'], default='geometric', help="type of graph to generate")
    parser.add_argument("--pairs", type=int, default=10, help="number of source-target pairs")
    parser.add_argument("--seed", type=int, default=42, help="random seed")
    parser.add_argument("--out-csv", default="results.csv", help="CSV file to write results")
    parser.add_argument("--heuristic", choices=['euclidean','zero'], default='euclidean', help="heuristic for A*")
    args = parser.parse_args()

    n = args.nodes
    print(f"[INFO] Generating {args.graph_type} graph: nodes={n}")

    if args.graph_type == 'geometric':
        g, coords = geometric_graph(n=n, k_neighbors=args.k, seed=args.seed)
        # For geometric graphs, we used Euclidean weights -> Euclidean heuristic is admissible
        if args.heuristic == 'zero':
            print("[WARN] Using zero heuristic on geometric graph (A* == Dijkstra).")
    else:
        g, coords = random_weight_graph(n=n, m=args.edges, seed=args.seed)
        if args.heuristic == 'euclidean':
            print("[WARN] Using Euclidean heuristic on random-weight graph: heuristic may be inadmissible.")

    nodes_list = g.nodes()
    print(f"[INFO] Graph has approx {len(nodes_list)} nodes. (adj-list keys: {len(g.adj)})")

    pairs = pick_random_pairs(n, args.pairs, seed=args.seed)
    print(f"[INFO] Running experiments on {len(pairs)} pairs...")

    results = run_experiment(g, coords, pairs, heuristic=args.heuristic)
    write_csv(args.out_csv, results)
    print(f"[INFO] Results written to {args.out_csv}\n")

    print("=== Detailed per-pair table ===")
    print(pretty_table(results))
    print("\n=== Summary ===")
    print(summarize_results(results))

    # Save a short textual report to file
    with open("report.txt", "w") as f:
        f.write("Dijkstra vs A* Experiment Report\n")
        f.write("===============================\n\n")
        f.write(f"Graph type: {args.graph_type}\n")
        f.write(f"Nodes: {n}\n")
        f.write(f"Pairs tested: {len(pairs)}\n\n")
        f.write("Summary:\n")
        f.write(summarize_results(results))
    print("[INFO] A short report saved to report.txt")

if __name__ == "__main__":
    main()
